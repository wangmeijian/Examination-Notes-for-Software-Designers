## 第五章 软件工程基础知识

5.1

计算机软件十大类

* 系统软件，服务其它程序的程序，和计算机硬件大量交互
* 应用软件，解决特定业务的程序
* 工程/科学软件，通常带有“数值计算”算法的特性
* 嵌入式软件，嵌入软件在某个产品或系统中，如微波炉的按键控制，汽车仪表盘显示
* 产品线软件，为多个用户的使用提供特定功能，如数据库管理
* web应用，以网络为中心的软件
* 人工智能软件，利用非数字算法解决计算和直接分析无法解决的复杂问题，如机器人
* 开放计算
* 网络资源
* 开源软件

软件开发的几个阶段：

* 可行性分析与项目开发计划=>产出=>可行性分析报告和项目开发计划
* 需求分析，确定软件功能、性能、数据和界面等要求=>需求说明书
* 概要设计=>概要设计说明书
* 详细设计=>详细设计文档
* 编码=>代码
* 测试=>软件测试计划、测试用例、软件测试报告
* 维护

软件过程能力成熟度模型CMM，分5个级别

* 初始级（Initial）：杂乱无章，没有明确定义的步骤，项目的完成全靠个人努力或核心人物的作用
* 可重复级（Repeatable）：建立了基本项目管理过程和实践来跟踪项目费用、进度、功能特性，有必要的准则来重复以前在同类项目中的成功
* 已定义级（Defined）：管理和工程两方面的软件过程已经文档化、标准化
* 已管理级（Managed）：制定了软件过程和产品质量的详细度量标准
* 优化级（Optimized）：通过来自质量反馈和新观念、新技术的反馈使过程能不断持续改进

### 软件过程模型
* 瀑布模型 Waterfall Model，适用于需求完整、简明、一致的系统开发，指导项目结束前都不能出一个版本演示
* 增量模型 Incremental Model，第一个可交付的版本所需成本和时间很少
* 演化模型 Evolutionary Model，适合系统规模不大、需求不清、需求经常变换的场景
	* 原型模型 Prototype Model，原型是预期系统的一个可执行版本
	* 螺旋模型 Spiral Model，将瀑布模型和演化模型结合起来，加入风险分析，支持用户需求动态变化
￼

* 喷泉模型 Water Fountain Model，以用户需求为动力，以对象作为驱动的模型，适合面向对象开发法，开发过程具有迭代性和无间隙姓
￼

* 基于构件的开发模型 Component-based Development Model，利用预先包装的构件来构造应用系统
* 形式化方法模型 Formal Methods Model，建立在严格数学基础上的一种软件开发方法
* 统一过程（UP）模型，用例和风险驱动、以架构为中心、迭代并且增量的开发过程，由UML方法和工具支持
	* 统一过程定义了4个技术阶段及其制品
		1. 起始阶段，产出构想文档、初始用例模型、初始项目术语表、初始业务用例、初始风险评估、项目计划、业务模型、一个或多个原型
		2. 精化阶段，需求分析和架构演进
		3. 构件阶段，关注系统的构建，产生实现模型
		4. 移交阶段，产出提交的软件增量、测试报告、用户反馈
* 敏捷方法 Agile Development，尽肯能早地、持续地对有价值的软件的交付，让客户满意
	* 极限编程（XP）：XP是一种轻量级、高效、低风险、柔性、可预测的、科学的软件开发方式
		* 4大价值观：沟通、简单性、反馈、勇气
		* 5个原则：快速反馈、简单性假设、逐步修改、提倡更改和优质工作
		* 12个最佳实践：
			1. 计划游戏（快速制定计划、随着细节变化而完善）
			2. 小型发布（系统设计要尽可能早地交付）
			3. 隐喻（找到合适的比喻传达信息）
			4. 简单设计（只处理当前的需求，让设计保持简单）
			5. 测试先行（先写测试代码，再编程）
			6. 重构（重新审视需求&设计，重新明确地描述它们以符合新的和现有的需求）
			7. 结对编程（两个人共用一台机写代码）
			8. 集体代码所有制（各个模块代码不归属于个人）
			9. 持续集成（可以按日甚至小时为客户提供可运行的版本）
			10. 每周工作40小时（正常工作日嘛）
			11. 现场客户（客户与开发团队一起工作）
			12. 编码标准
			
	* 水晶法（Crystal）：每个不同的项目都要一套不同的策略、约定和方法论
	* 并列争求（Scrum）法：把项目拆分成一个个小目标，按周期迭代
	* 自适应软件开发（ADS）:顾名思义，开发过程中伴随着变化，开发必须考虑每一个生产版本的关键需求
	* 敏捷统一过程（AUP）：采用“在大型上连续”，“在小型上迭代”的原理来构建软件系统

### 需求工程
* 需求获取：通过与用户的交流、对系统的分析开发出的原型
* 需求分析与协商：分析需求一致性、重叠、优先级并解决这些问题
* 系统建模：在用户和系统分析人员之间建立理解的桥梁，分析策略分为
	* 面向数据流的结构化分析方法（SA）
	* 面向对象的分析方法（OOA）
* 需求规约：产出完整的功能和行为描述、性能需求、设计约束
* 需求验证：检验需求功能的正确性、完整性、清晰性
* 需求管理：是一种获取、组织并记录系统需求的系统化方案

### 系统设计
* 概要设计：划分模块，确定功能与模块间的关系
* 详细设计：包括算法、数据结构、数据库、UI，产出设计文档并评审

### 系统测试
1. 尽早不断第测试
2. 测试应避免由原开发人承担
3. 要明确输入输出结果
4. 对异常、不合理、意外情况进行测试
5. 检验程序是否做了不该做的事（副作用）
6. 避免测试随意性，严格按照计划测试
7. 保存测试计划、测试用例
8. 测试用例需重复测试

### 传统软件测试策略
* 单元测试：侧重于模块内部处理逻辑和数据结构
* 集成测试：将模块组合起来测试
* 确认测试：确认软件满足需求，内容准确无误，性能达标，文档可用，文档、（初始化）数据齐全
	* α、β测试：α测试是由有代表性的最终用户在开发场所进行，软件运行在受控自然环境下，开发者在后面记录错误和使用问题，β测试在一个或多个最终用户场所执行，由用户记录问题定期提交给开发者
* 系统测试：将软件、硬件、外设、网络等因素结合在一起测试
	* 恢复测试：处理错误不能阻塞系统，需在指定时间内恢复
	* 安全性测试
	* 压力测试：以非正常的数量、频率等方式执行系统
	* 性能测试：通常和压力测试一起进行
	* 部署测试：在软件将要运行的每一种环境中测试

### 测试方法
* 黑盒测试：也叫功能测试，不考虑软件内部结构和特性，只测试软件外部特性
	1. 等价类划分：将输入域划分为若干等价类，从每个等价类中去一个代表性数据作为测试用例
	2. 边界值分析：输入的边界比中间更容易发生错误
	3. 错误推测：基于经验和直觉（玄学）推测程序中可能存在的错误，从而针对性地设计测试用例
	4. 因果图：着重测试规格说明中的输入输出的依赖关系
* 白盒测试：也叫结构测试，根据程序内部结构和逻辑来设计用例，对程序的路径和过程进行测试
	1. 逻辑覆盖：考察队程序逻辑的覆盖程度。有语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖、路径覆盖
	2. 循环覆盖：执行足够多的测试用例，使得循环中每个条件都得到验证
	3. 基本路径测试：测试用例保证在测试中程序的每一天独立路径都执行过

### 调试方法
试探法：分析错误症状，猜测问题所在
回溯法：从错误的位置开始，沿着控制流程跟踪代码
对分查找法：修改变量值达到缩小错误范围的目的
归纳法：根据测试暴露的问题分析错误原因
演绎法：列出所有原因，根据已有数据，排除不可能的原因（叫排除法好了）

### 软件项目估算
* 成本估算

	* 根据人员以前完成项目的总成本推算将要开发软件的总成本（自顶向下估算法）
	* 将待开发的软件细分，分布估算每个子任务的开发量（自底向上估算法）
	* 将待开发的项目与类似的已完成的项目比较，找出不同并估算成本（差别估算法）
	* ……
	
* COCOMO估算模型
	* E = a(L)b↑
	* D = c(E)D↑
* COCOMO2估算模型 
* Putnam估算模型

### 进度管理
1. Gantt图：能清晰第描述任务开始、结束时间，任务进展以及各个任务自己的并行性
2. PERT图：PERT图不仅给出了每个任务的开始时间、结束时间和完成任务所需时间，还给出了任务之间的关系

项目松弛时间 = 最晚开始时间 - 最早开始时间，其中最晚开始时间 = 关键路径时间 - 指定事件到汇点的时间

项目松弛时间 = 关键路径总时间 - 包含该任务的关键路径花的时间


### 软件质量保证
1. 应用技术方法：把软件质量设计到软件产品或软件系统中
2. 技术评审：能揭露软件质量问题
3. 软件测试：发现问题，解决问题
4. 标准的实施：类似于JSLint
5. 控制变更：需求变更可能引入错误或其他问题
6. 度量：跟踪软件质量和程序上的变更对软件质量的影响程度
7. 记录保存和报告：便于维护

### 软件复杂性度量
1. 环路度量（McCabe度量法），V(G) = m - n + 2p，m为弧线条数，n为节点个数，p为强连通分量个数（所谓强连通，就是起点和终点都有一条有向路径连通），另一种算法是V(G) = P + 1,P为有判断条件的节点个数(有分支的节点就是判定节点)

