## 第三章 数据结构
3.1

线性结构
LOC(a1)表示线性表中第一个元素的存储位置，第i个元素的存储位置为

LOC(ai) = LOC(a1) + (i - 1)*L

L是每个数据元素所占空间字节数（意味着每个数据元素所占空间一样大）

在表长为n的线性表中插入新元素时，共有n+1个插入位置，插入一个新元素需要移动的元素个数期望值为n/2

在表长为n的线性表中删除元素时，共有n个可删除的元素，删除一个元素需要移动的元素个数期望值为（n-1）/2

线性表的顺序存储，可以随机访问元素，但是插入、删除元素会移动元素

链式存储结构中，插入和删除元素，实质都是对相关指针的修改，因此不会移动元素，逻辑关系需要额外空间存储

在链式存储中，假设front和next分别表示当前节点的直接前驱和直接后继，A、B之间插入C，会自动将
1. C->front = B->front = A
2. B->front->next = C
3. C->next = B
4. B->front = C

#### 栈和队列
栈是只能通过访问它的一端来实现数据存储和检索的一种线性数据结构，顺序存储的栈push一个元素需要先判断是否栈满

队列是一种先进先出的线性表，只允许在一端插入元素，另一端删除元素，元素入队只修改队尾指针，出队时只修改队头指针

串是一种有序线性表，其数据元素为字符，一般记为S='a1a2...an'

子串是由串中任意长度连续字符构成的序列，含有子串的串叫主串，子串在主串中的位置以子串首字符为准，空串是任意串的子串，串比较：ASCII码大的串大||串长的为大

#### 串的模式匹配（子串的定位）
1. 朴素的模式匹配算法：从主串首字符与子串首字符逐个比较，相等则逐一进行后续比较，不等则从主串第二字符与子串首字符比较
2. KMP算法：当匹配过程中出现比较的字符不等时，不需要从头开始比较，而是将部分匹配的结果串向右“滑动”再进行比较

3.3
#### 树
* 结点的度：也就是拥有子结点个数，不包括孙子以下结点
* 叶子结点：即度为0的结点
* 内部节点：度不为0的结点
* 树的高度：一棵树最大层数为树的高度（或深度）
* 有序树：结点不能交换
* 二叉树：由一个根结点+两棵不相交的分别称左子树、右子树的二叉树所组成，二叉树结点最大度为2（一个结点最多俩子结点），第i层最多有2的i-1次方个结点，整棵树最多有2的k次方-1个结点，任意二叉树的叶子节点数=度为2的结点数+1
* 满二叉树：有2的k次方-1个结点的二叉树
* 完全二叉树：约定编号从根节点起从上到下从左到右，当且仅当每个几点都与编号从1到n的结点一一对应，从上到下从左到右的结点必须都存在，不能有空结点
* 二叉树遍历使得每个结点在这些线性序列中有且仅有一个直接前驱和直接后继，仅在遍历过程中才能得到，线索二叉树就是用来保存这些动态过程中得到的消息，指向前驱、后继的指针称为线索

#### 二叉树遍历：先序、中序、后序
* 先序：根节点、左节点、右节点，先访问**根节点**
* 中序：左节点、根节点、右节点，中间访问**根节点**
* 后序：左节点、右节点、根节点，最后访问**根节点**

#### 哈夫曼树(最优二叉树)
哈夫曼树又叫最优二叉树，它是一类**带权路径**长度最短的树

路径指从树中一个结点到另一个结点之间的通路，路径上的分支数目称为路径长度

树的路径长度是从树根到每个叶子之间的路径长度之和

结点的带权路径长度为从该结点到树根之间的路径长度与该结点权值的乘积（结点的深度*结点权值）

树的带权路径长度为树种所有叶子结点的带权路径长度之和

哈夫曼树是指带权路径长度最小的二叉树

构造最优二叉树：给定n个权值，依次选择最小的两个权值组成二叉树，组成二叉树的树根结点继续跟最小权值组成二叉树，直到取完给定的n个权值，二叉树的每个左分支上标0，右分支上标1，那么每个叶子结点代表的字符编码就是从根到叶子的路径上的0、1组成的串串

给定n个权值，构造出的哈夫曼树节点数目m=2n-1

#### 哈夫曼编码
前缀码：任一字符都不是另一字符编码的前缀

### 树和森林
1. 双亲表示法：用一组地址连续的单元存储树的结点，每个结点有个指示器表示双亲结点在该存储中的位置
2. 孩子表示法：用指针指出结点每个孩子，为孩子建立一个链表
3. 孩子兄弟表示法：两个指针分别指向第一个孩子和下一个兄弟

#### 树的遍历
* 先根遍历：先访问根节点，在遍历各子树，等于先序遍历
* 后根遍历：先遍历树根的各子树，再访问根节点，等于中序遍历

#### 森林的遍历就是依次遍历树

### 图
* 有向图：每条边都有方向
* 无向图：每条边都没方向
* 完全图：无向图的每两个顶点之间都有一条边，n个顶点的完全图共有n(n-1)/2条边，类似的，有向完全图中弧的数目为n(n-1)条
* 度、出度、入度：度就是关联于顶点的边的数目，出度就是以该顶点为起点，反之就是入度，度=出度+入度
* 路径
* 网：边带权值的图称为网


#### 最小生成树
n个顶点的连通图至少有n-1条边，生成树恰好有n-1条边，若在生成树中任意加一条边必然形成回路

图的生成树不唯一，按深度和广度优先遍历将得到不同的生成树

#### 最小生成树：各条边权值之和最小，最小生成树求解算法有普利姆（Prim）算法和（Kruskal）算法

### 拓扑排序和关键路径

AOV网：以顶点表示活动，边表示关系的有向图

判断工程是否可行，关键在于检查AOV网是否存在回路，检测方法是：依次找出并输出一个入度为0的顶点，然后删除它以及它的边，所有顶点都输出了表示不存在回路

AOE网：以顶点表示活动，边表示关系的带权的有向图

关键路径：从起点到终点，长度最长的路径

顶点事件最早发生时间=起点到该顶点的关键路径长度

顶点事件最晚发生时间要看关键路径上的延误时间

#### 最短路径
单源点最短路径：指从源点到其余各顶点的最短路径

### 查找

静态查找表：查询查找表中某数据是否存在 || 查询某数据的各种属性

动态查找表：新增、删除数据

二叉排序树：它是空树或具有以下特点的二叉树

1. 若它的左子树非空，左子树上所有节点的值都小于根节点的值
2. 若它的右子树非空，右子树上所有节点的值都大于根节点的值

在二叉排序树中插入结点的操作：每读入一个元素，建立一个新结点，若二叉树非空，新结点值与根节点比较，小=>左子树，大=>右子树，若二叉树为空，新结点就是根结点

#### 平衡二叉树：左右子树高度差<=1

