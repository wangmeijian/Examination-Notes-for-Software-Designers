## 第三章 数据结构
3.1

线性结构
LOC(a1)表示线性表中第一个元素的存储位置，第i个元素的存储位置为

LOC(ai) = LOC(a1) + (i - 1)*L

L是每个数据元素所占空间字节数（意味着每个数据元素所占空间一样大）

在表长为n的线性表中插入新元素时，共有n+1个插入位置，插入一个新元素需要移动的元素个数期望值为n/2

在表长为n的线性表中删除元素时，共有n个可删除的元素，删除一个元素需要移动的元素个数期望值为（n-1）/2

线性表的顺序存储，可以随机访问元素，但是插入、删除元素会移动元素

链式存储结构中，插入和删除元素，实质都是对相关指针的修改，因此不会移动元素，逻辑关系需要额外空间存储

在链式存储中，假设front和next分别表示当前节点的直接前驱和直接后继，A、B之间插入C，会自动将
1. C->front = B->front = A
2. B->front->next = C
3. C->next = B
4. B->front = C

#### 栈和队列
栈是只能通过访问它的一端来实现数据存储和检索的一种线性数据结构，顺序存储的栈push一个元素需要先判断是否栈满

队列是一种先进先出的线性表，只允许在一端插入元素，另一端删除元素，元素入队只修改队尾指针，出队时只修改队头指针

串是一种有序线性表，其数据元素为字符，一般记为S='a1a2...an'

子串是由串中任意长度连续字符构成的序列，含有子串的串叫主串，子串在主串中的位置以子串首字符为准，空串是任意串的子串，串比较：ASCII码大的串大||串长的为大

#### 串的模式匹配（子串的定位）
1. 朴素的模式匹配算法：从主串首字符与子串首字符逐个比较，相等则逐一进行后续比较，不等则从主串第二字符与子串首字符比较
2. KMP算法：当匹配过程中出现比较的字符不等时，不需要从头开始比较，而是将部分匹配的结果串向右“滑动”再进行比较

3.3
#### 树
* 结点的度：也就是子结点个数，不包括孙子以下结点
* 叶子结点：即度为0的结点
* 内部节点：度不为0的结点
* 树的高度：一棵树最大层数为树的高度（或深度）
* 有序树：结点不能交换
* 二叉树：由一个根结点+两棵不相交的分别称左子树、右子树的二叉树所组成，二叉树结点最大度为2（一个结点最多俩子结点），第i层最多有2的i-1次方个结点，整棵树最多有2的k次方-1个结点，任意二叉树的叶子节点数=度为2的结点数+1
* 满二叉树：有2的k次方-1个结点的二叉树
* 完全二叉树：约定编号从根节点起从上到下从左到右，当且仅当每个几点都与编号从1到n的结点一一对应，从上到下从左到右的结点必须都存在，不能有空结点
* 二叉树遍历使得每个结点在这些线性序列中有且仅有一个直接前驱和直接后继，仅在遍历过程中才能得到，线索二叉树就是用来保存这些动态过程中得到的消息，指向前驱、后继的指针称为线索

#### 二叉树遍历：先序、中序、后序
* 先序：根节点、左节点、右节点，先访问**根节点**
* 中序：左节点、根节点、右节点，中间访问**根节点**
* 后序：左节点、右节点、根节点，最后访问**根节点**

