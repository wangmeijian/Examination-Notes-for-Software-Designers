## 第三章 数据结构
3.1

线性结构
LOC(a1)表示线性表中第一个元素的存储位置，第i个元素的存储位置为

LOC(ai) = LOC(a1) + (i - 1)*L

L是每个数据元素所占空间字节数

在表长为n的线性表中插入新元素时，共有n+1个插入位置，插入一个新元素需要移动的元素个数期望值为n/2

在表长为n的线性表中删除元素时，共有n个可删除的元素，删除一个元素需要移动的元素个数期望值为（n-1）/2

顺序存储结构特点：顺序存储，随机存取

链式存储结构特点：随机存储，顺序存取

线性表的顺序存储，无需额外空间来存储元素间的逻辑关系，可以随机访问元素，但是插入、删除元素会移动元素

链式存储结构中，利用指针链接起来的结点来存储数据元素，插入和删除元素，实质都是对相关指针的修改，因此不会移动元素，逻辑关系需要额外空间存储

在链式存储中，假设front和next分别表示当前节点的直接前驱和直接后继，A、B之间插入C，会自动将
1. C->front = B->front = A
2. B->front->next = C
3. C->next = B
4. B->front = C

#### 栈和队列
栈是只能通过访问它的一端来实现数据存储和检索的一种线性数据结构，顺序存储的栈push一个元素需要先判断是否栈满

队列是一种先进先出的线性表，只允许在一端插入元素，另一端删除元素，元素入队只修改队尾指针，出队时只修改队头指针

串是一种有序线性表，其数据元素为字符，一般记为S='a1a2...an'

子串是由串中任意长度连续字符构成的序列，含有子串的串叫主串，子串在主串中的位置以子串首字符为准，空串是任意串的子串，串比较：ASCII码大的串大||串长的为大

#### 串的模式匹配（子串的定位）
1. 朴素的模式匹配算法：从主串首字符与子串首字符逐个比较，相等则逐一进行后续比较，不等则从主串第二字符与子串首字符比较
2. KMP算法：当匹配过程中出现比较的字符不等时，不需要从头开始比较，而是将部分匹配的结果串向右“滑动”再进行比较

3.3
#### 树
* 结点的度：也就是拥有子结点个数，不包括孙子以下结点
* 叶子结点：即度为0的结点
* 内部节点：度不为0的结点
* 树的高度：一棵树最大层数为树的高度（或深度）
* 有序树：结点不能交换
* 二叉树：由一个根结点+两棵不相交的分别称左子树、右子树的二叉树所组成，二叉树结点最大度为2（一个结点最多俩子结点），第i层最多有2的i-1次方个结点，整棵树最多有2的k次方-1个结点，任意二叉树的叶子节点数=度为2的结点数+1
* 满二叉树：有2的k次方-1个结点的二叉树
* 完全二叉树：约定编号从根节点起从上到下从左到右，当且仅当每个几点都与编号从1到n的结点一一对应，从上到下从左到右的结点必须都存在，不能有空结点
* 二叉树遍历使得每个结点在这些线性序列中有且仅有一个直接前驱和直接后继，仅在遍历过程中才能得到，线索二叉树就是用来保存这些动态过程中得到的消息，指向前驱、后继的指针称为线索

#### 二叉树遍历：先序、中序、后序
* 先序：根节点、左节点、右节点，先访问**根节点**
* 中序：左节点、根节点、右节点，中间访问**根节点**
* 后序：左节点、右节点、根节点，最后访问**根节点**

#### 哈夫曼树(最优二叉树)
哈夫曼树又叫最优二叉树，它是一类**带权路径**长度最短的树

路径指从树中一个结点到另一个结点之间的通路，路径上的分支数目称为路径长度

树的路径长度是从树根到每个叶子之间的路径长度之和

结点的带权路径长度为从该结点到树根之间的路径长度与该结点权值的乘积（结点的深度*结点权值）

树的带权路径长度为树种所有叶子结点的带权路径长度之和

哈夫曼树是指带权路径长度最小的二叉树

构造最优二叉树：给定n个权值，依次选择最小的两个权值组成二叉树，权值小的在左侧，大的在右侧，组成二叉树的树根结点继续跟最小权值组成二叉树，直到取完给定的n个权值，二叉树的每个左分支上标0，右分支上标1，那么每个叶子结点代表的字符编码就是从根到叶子的路径上的0、1组成的串串

给定n个权值，构造出的哈夫曼树节点数目m=2n-1

#### 哈夫曼编码
前缀码：任一字符都不是另一字符编码的前缀

### 树和森林

树的存储结构：

1. 双亲表示法：用一组地址连续的单元存储树的结点，每个结点有个指示器表示双亲结点在该存储中的位置
2. 孩子表示法：用指针指出结点每个孩子，为孩子建立一个链表
3. 孩子兄弟表示法：两个指针分别指向第一个孩子和下一个兄弟

#### 树的遍历
* 先根遍历：先访问根节点，在遍历各子树，等于先序遍历
* 后根遍历：先遍历树根的各子树，再访问根节点，等于中序遍历

#### 森林的遍历就是依次遍历树

### 图
* 有向图：每条边都有方向
* 无向图：每条边都没方向
* 完全图：无向图的每两个顶点之间都有一条边，n个顶点的完全图共有n(n-1)/2条边，类似的，有向完全图中弧的数目为n(n-1)条
* 度、出度、入度：度就是关联于顶点的边的数目，出度就是以该顶点为起点，反之就是入度，度=出度+入度
* 路径
* 连通图与连通分量：无向图中任意两个顶点都是连通的（注:连通并不一定是一条边，可通过其他顶点间接连通），叫连通图，无向图的极大连通子图叫连通分量
* 强连通图（每一对顶点，如A和B，A到B和B到A都存在路径）和强连通分量
* 网：边带权值的图称为网
* 有向树：一个有向图恰有一个顶点入度为0，其余顶点入度均为1，则是一颗有向树

PS：非连通图即有至少一个顶点是没有跟其他顶点连接的

#### 图的存储结构
分为邻接矩阵表示法和邻接链表表示法

1. 邻接矩阵表示法：用一个矩阵来表示图中顶点之间的关系，满足：

A[i][j] = {
	1 (Vi, Vj)或<Vi, Vj>是E中的边
	0 (Vi, Vj)或<Vi, Vj>不是E中的边
}

图的邻接矩阵表示法为：
1 ----> 2
|
|
|
V<------
3-----> 4

0 1 1 0  (这一行分别表示1->1,1->2,1->3,1->4方向有没有边相连接，有则为1，否则为0)
0 0 0 0
0 0 0 1
0 0 1 0

2. 邻接链表表示法

图的邻接链表表示法为：
V1 ----> V2
|
|
|
V<------
V3-----> V4

1 V1: ->2->3^
2 V2: ^
3 V3: ->4^
4 V4: ->3^

对于无向图，顶点Vi的度是邻接矩阵第i行或列中值不为0的元素个数  
对于有向图，第i行或列中值不为0的元素个数是顶点Vi的出度，第j列的非0元素个数是顶点Vj的入度  



#### 图的遍历
* 深度优先搜索：类似于树的先根遍历，第一次经过顶点时就进行访问
* 广度优先搜索：从顶点v出发，访问v之后依次访问v的各个未被访问过的邻接点，以此类推

#### 最小生成树
n个顶点的连通图至少有n-1条边，生成树恰好有n-1条边，若在生成树中任意加一条边必然形成回路

图的生成树不唯一，按深度和广度优先遍历将得到不同的生成树

#### 最小生成树：各条边权值之和最小，最小生成树求解算法有普利姆（Prim）算法和（Kruskal）算法

### 拓扑排序和关键路径

AOV网：以顶点表示活动，边表示关系的有向图

判断工程是否可行，关键在于检查AOV网是否存在回路，检测方法是：依次找出并输出一个入度为0的顶点，然后删除它以及它的边，所有顶点都输出了表示不存在回路

AOE网：以顶点表示活动，边表示关系的带权的有向图

关键路径：从起点到终点，长度最长的路径

顶点事件最早发生时间=起点到该顶点的关键路径长度

顶点事件最晚发生时间要看关键路径上的延误时间

#### 最短路径
单源点最短路径：指从源点到其余各顶点的最短路径

### 查找
查找是一种常用的基本运算，查找表是由同一类型的数据元素构成的集合  
静态查找表：查询查找表中某数据是否存在 || 查询某数据的各种属性

动态查找表：新增、删除数据

线性表利用线性探测解决冲突，平均查找长度为每个元素存入线性表的查找次数之和除以线性表长度（实际长度）

二叉排序树：它是空树或具有以下特点的二叉树

1. 若它的左子树非空，左子树上所有节点的值都小于根节点的值
2. 若它的右子树非空，右子树上所有节点的值都大于根节点的值

在二叉排序树中插入结点的操作：每读入一个元素，建立一个新结点，若二叉树非空，新结点值与根节点比较，小=>左子树，大=>右子树，若二叉树为空，新结点就是根结点

#### 平衡二叉树

左右子树高度差<=1
#### 平衡二叉树的插入操作
* LL型单向右旋平衡处理，LL即在左子树的左子树插入新结点
* RR型单向左旋平衡处理，RR即在右子树的右子树插入新结点
* LR型先左后右双向旋平衡处理
* RL型先右后左双向旋转平衡处理

#### 构造平衡二叉树

规则参照二叉排序树

### 如何构造哈希函数	

直接定址法、数字分析法、平方取中法、折叠法、随机数法、除留余数法

### 处理哈希表冲突
1. 开放地址法：依次将每个关键字代入哈希函数，所得结果为哈希地址，若被占用，顺序地存储到下一个单元（线性探测）
2. 链地址法：在查找表的每个记录中增加一个链域，链域中存放下一个具有相同哈希函数值的记录的存储地址
3. 再哈希法：有多个哈希函数，如果哈希地址冲突就换一个函数计算直到不冲突为止，增加了计算时间
4. 建立公共溢出区，一旦有冲突，都填入到公共溢出区


3.6
## 排序 

动画：https://www.cnblogs.com/fivestudy/p/10212306.html  

* 直接插入排序

设有一组关键字｛K1， K2，…， Kn｝；排序开始就认为 K1 是一个有序序列；让 K2 插入上述表长为 1 的有序序列，使之成为一个表长为 2 的有序序列；然后让 K3 插入上述表长为 2 的有序序列（注意：不是从头开始比较，而是从末尾往前比较），使之成为一个表长为 3 的有序序列；依次类推，最后让 Kn 插入上述表长为 n-1 的有序序列，得一个表长为 n 的有序序列。

* 希尔排序（对直接插入排序的改进，叫插入排序Plus好了）

将数组按指定增量取一个数据（如隔4个取一个）的方式将数组分成多个组，每个组两位数进行比较并交换位置（如果前面数字大的话），如果数据集较大，第二次增量改为第一次的一半，继续分组进行插入排序，直到增量为1

==========

* 冒泡排序

依次比较n和n+1个元素的大小，大的放后面，经过多次比较和位置交换后，找出最大值，多次循环后排序完成

* 选择排序

长度为n的数组，通过n-1次比较，找出最小值放在首位，再通过n-2次比较找出次最小值放在第二位，以此类推

==========

* 快速排序（找基准，分两半，再两半）

通过一次排序将待排记录分为两部分，前半区和后半区，其中，前半区的值均<=后半区的值，然后分别对前后半区继续快排，直到整个序列有序

* 堆排序

堆是具有以下特性的完全二叉树：

每个结点的值都>=其左右孩子结点的值（大顶堆）：arr[i]>=arr[2i+1]&&arr[i]>=arr[2i+2]

或每个结点值都<=其左右孩子结点的值（小顶堆）：arr[i]<=arr[2i+1]&&arr[i]<=arr[2i+2]）

1. 将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;
2. 将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;
3. 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。

* 基数排序

将所有待排序的值统一为同样的数位长度，不够长的前面补0，然后从最低位（个位）开始排序，小的在前大的在后

* 归并排序

对数组来说，将数组拆分为N个长度为2的子数组分别排序，然后子数组两两合并后继续排序（@五分钟学算法），直到最终合并为一个数组

数组两两合并后排序是将后面数组中最小值依次与前面数组元素逐个比较，A、B分别代表前后数组，若A数组长度为2，则B数组与A数组元素比较次数最多为2，B数组元素不会再次与B数组元素（已比较完成的元素）再次比较

### 排序总结
1. 待排序数目少，用直接插入法和简单选择法排序，因插入法移动操作比简单选择法多，当记录本身信息量大时，优先用简单选择法排序
2. 待排序记录基本有序，用直接插入或冒泡排序
3. 待排序数目多且位数少，用基数排序
4. 待排序数目多