### 7.1 类
类分三种：

实体类：现实世界中真实的实体

接口类（边界类）：为用户提供一种与系统合作交互的方式

控制类

子类从单个父类得到继承叫“单重继承”，从多个父类得到继承叫“多重继承”

多态：不同对象收到同一消息可以产生完全不同的结果，这就是多态

#### 面向对象设计原则
1. 单一责任：就一个类而言，应该仅有一个引起它变化的原因
2. 开放-封闭：软件实体（类、模块、函数）应该是可以扩展但是不可修改的
3. 里氏替换：子类型必须能替换掉他们的基类型（父类的实例）
4. 依赖倒置：抽象不应该依赖于细节，细节依赖于抽象。高层模块不应该依赖于低层模块，二者都应该依赖于抽象
5. 接口分离：依赖于抽象，不依赖于具体，最大限度应对可能的变化

对象和类的本质区别是：对象之间通过消息传递方式进行通信

重置：在子类中重新定义父类中已经定义的方法

类属类：是关于一组类的一个特性抽象，强调的是这些类的成员特性中与具体类型无关的那些部分，比如卡车、面包车、救护车都是属于汽车，汽车就是一个类属类

#### 面向对象软件测试
1. 算法层：测试类中定义的每个方法，基本上相当于传统软件测试的单元测试
2. 类层：测试类中定义的每个方法与属性之间的相互作用，相当于模块测试
3. 模板层：测试一组协同工作的类之间的相互作用，相当于集成测试
4. 系统层：把各个子系统组装成完整的面向对象软件系统，在组装过程中同时进行测试

#### UML（统一建模语言）

* 结构事物：通常是模型的静态部分，包括类、接口、协作、用例、主动类、构件、制品、结点
* 行为事物：模型的动态部分，描述了跨越时间和空间的行为，包括交互、状态机、活动
* 分组事物：是UML模型的组织部分
* 注释事物：是UML模型的解释部分

UML中有4种关系：

依赖：一个事物变化会影响另一个事物

关联：描述了一组链，链是对象之间的连接

泛化

实现

### 7.3 设计模式

每个模式描述了一个在我们周围不断重复发生的问题以及该问题的解决方案的核心

#### 创建型设计模式

1. Abstract Fatory（抽象工厂）

提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类

适用于：

一个系统要独立于它的产品的创建、组合和表示时

一个系统要由多个产品系列中的一个来配置时

当强调一些人相关产品对象的设计以便进行联合使用时

当提供一个产品类库，只想显示它们的接口而不是实现时

2. Builder （生成器）

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

适用于：

当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时

当构造过程必须允许被构造的对象有不同的表示时

3. Factory Method (工厂方法)

定义一个用于创建对象的接口，让之类决定实例化哪一个类，Factory Method使一个类的实例化延迟到其子类

适用性：

当一个类不知道它所必须创建的对象的类的时候

当一个类希望由它的子类来指定它所创建的对象的时候

当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候

4. Prototype （原型）

用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象

适用性：

一个系统要独立于它的产品的创建、组合和表示时

当要实例化的类是在运行时刻指定时，如，通过动态装载

为了避免创建一个与产品类层次平行的工厂类层次时

当一个类的实例只能有几个不同状态组合中的一种时

5. Singleton (单例)

保证一个类仅有一个实例，并提供一个访问它的全局访问点

#### 结构型设计模式

1. Adapter（适配器）：将一个类的接口转换成客户希望的另一个接口以兼容
2. Bridge （桥接）：将抽象部分与实现部分分离，使得它们都可以独立地变化
3. Composite（组合）：将对象组合成树形结构以表示“部分-整体”的层次结构
4. Decorator（装饰）：动态地给一个对象添加额外的职责，比生成子类更灵活
5. Facade（外观）：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，使得这一子系统更加容易使用
6. Flyweight（享元）：用共享技术有效地支持大量细粒度的对象
7. Proxy（代理）：为其它对象提供代理以控制对这个对象的访问