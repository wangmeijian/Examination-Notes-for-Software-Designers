 ### 7.1 类
类分三种：

实体类：现实世界中真实的实体

接口类（边界类）：为用户提供一种与系统合作交互的方式

控制类：用来控制活动流，充当协调者

子类从单个父类得到继承叫“单重继承”，从多个父类得到继承叫“多重继承”

多态：不同对象收到同一消息可以产生完全不同的结果，这就是多态

#### 多态的分类
通用多态：参数多态、包含多态  

特定多态：过载多态、强制多态  

#### 面向对象设计原则
1. 单一责任：就一个类而言，应该仅有一个引起它变化的原因
2. 开放-封闭：软件实体（类、模块、函数）应该是可以扩展但是不可修改的
3. 里氏替换：子类型必须能替换掉他们的基类型（父类的实例）
4. 依赖倒置：抽象不应该依赖于细节，细节依赖于抽象。高层模块不应该依赖于低层模块，二者都应该依赖于抽象
5. 接口分离：依赖于抽象，不依赖于具体，最大限度应对可能的变化

**对象和类的本质区别是：对象之间通过消息传递方式进行通信**

重置：在子类中重新定义父类中已经定义的方法

类属类：是关于一组类的一个特性抽象，强调的是这些类的成员特性中与具体类型无关的那些部分，比如卡车、面包车、救护车都是属于汽车，汽车就是一个类属类

#### 面向对象测试
1. 算法层：测试类中定义的每个方法，基本上相当于传统软件测试的单元测试
2. 类层：测试类中定义的每个方法与属性之间的相互作用，相当于模块测试
3. 模板层：测试一组协同工作的类之间的相互作用，相当于集成测试
4. 系统层：把各个子系统组装成完整的面向对象软件系统，在组装过程中同时进行测试

#### UML（统一建模语言）

* 结构事物：通常是模型的静态部分，包括类、接口、协作、用例、主动类、构件、制品、结点
* 行为事物：模型的动态部分，描述了跨越时间和空间的行为，包括交互、状态机、活动
* 分组事物：是UML模型的组织部分
* 注释事物：是UML模型的解释部分

UML中有4种关系：

依赖：一个事物变化会影响另一个事物，图为一条可能有方向的虚线 - - - - - - - 右箭头

关联：描述了一组链，链是对象之间的连接，图为一条实线 ————————————————，聚集是一种特殊类型的关联，描述了整体和部分间的结构关系，图为实线+菱形 ——————————菱形

泛化：泛化是一种特殊/一般关系，特殊元素（子元素）的对象可以替代一般元素（父元素）的对象，图为带空心箭头的实线，指向父元素 ——————————空心箭头

实现：类元之间的语义关系，一个类元指定了由另一个类元保证执行的契约，图为带空心箭头的虚线 - - - - - - -空心箭头

#### UML中的图
1. 类图，展现了一组对象、接口、协作和它们之间的关系，包括类、接口、协作、依赖、泛化和关联关系  
2. 对象图，展现了某一时刻一组对象以及它们之间的关系，包括对象和链  
3. 用例图，展现了一组用例、参与者以及它们之间的关系，包括用例、参与者、用例之间的扩展关系（extend）和包含关系（include）  
4. 交互图，用于对系统的动态方面进行建模，包括一组对象和它们之间的关系及它们之间可能传递的消息  
5. 状态图，展现了一个状态机，它由状态、转换、事件和活动组成  
6. 活动图，一种特殊的状态图，展现了在系统内从一个活动到另一个活动的流程，包括状态、转换和对象  
7. 组件图，展现了一组组件之间的组织和依赖
8. 组合结构图，用于描述一个分类器（如类、组件或用例）的内部结构  
9. 部署图，用来对面向对象系统的物理方面建模的方法  
10. 包图，用于把模型本身组织成层次结构的通用机制，不能执行，展现由模型本身分解而成的组织单元以及其间的依赖关系  

### 7.3 设计模式

每个模式描述了一个在我们周围不断重复发生的问题以及该问题的解决方案的核心

#### 创建型设计模式：创建型模式与对象的创建有关

1. Abstract Fatory（抽象工厂）

提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类

适用于：

一个系统要独立于它的产品的创建、组合和表示时

一个系统要由多个产品系列中的一个来配置时

当强调一些人相关产品对象的设计以便进行联合使用时

当提供一个产品类库，只想显示它们的接口而不是实现时

2. Builder （生成器）

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

适用于：

当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时

当构造过程必须允许被构造的对象有不同的表示时

3. Factory Method (工厂方法)

定义一个用于创建对象的接口，让之类决定实例化哪一个类，Factory Method使一个类的实例化延迟到其子类

适用性：

当一个类不知道它所必须创建的对象的类的时候

当一个类希望由它的子类来指定它所创建的对象的时候

当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候

4. Prototype （原型）

用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象

适用性：

一个系统要独立于它的产品的创建、组合和表示时

当要实例化的类是在运行时刻指定时，如，通过动态装载

为了避免创建一个与产品类层次平行的工厂类层次时

当一个类的实例只能有几个不同状态组合中的一种时

5. Singleton (单例)

保证一个类仅有一个实例，并提供一个访问它的全局访问点

#### 结构型设计模式：处理类或对象的组合

1. Adapter（适配器）：将一个类的接口转换成客户希望的另一个接口以兼容
2. Bridge （桥接）：将抽象部分与实现部分分离，使得它们都可以独立地变化
3. Composite（组合）：将对象组合成树形结构以表示“部分-整体”的层次结构
4. Decorator（装饰）：动态地给一个对象添加额外的职责，比生成子类更灵活
5. Facade（外观）：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，使得这一子系统更加容易使用
6. Flyweight（享元）：用共享技术有效地支持大量细粒度的对象
7. Proxy（代理）：为其它对象提供代理以控制对这个对象的访问

#### 行为设计模式：对类或对象怎样交互和怎样分配职责进行描述

1. Mediator（中介者）：用一个中介对象来封装一系列的对象交互
2. Observer（观察者）：定义对象间一对多的依赖关系，当一个对象状态发生改变，所有依赖于它的对象都得到通知并被自动更新
3. State（状态）：允许一个对象在其内部状态改变时改变它的行为
4. Strategy（策略）：定义一系列算法封装起来，使它们可以相互替换
5. Template Method（模板方法）：定义操作中的算法骨架，将一些步骤延迟到子类中，使得子类可以不改变算法的结构就可以重定义该算法的某些步骤
6. Visitor（访问者）：表示一个作用于某对象结构中的各元素的操作，它允许在不改变各元素的前提下定义作用于这些元素的新操作
7. ……

